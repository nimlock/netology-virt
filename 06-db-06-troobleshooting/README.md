# Домашнее задание к занятию "6.6. Troubleshooting"

## Модуль 6. Администрирование баз данных

### Студент: Иван Жиляев

## Задача 1

>Перед выполнением задания ознакомьтесь с документацией по [администрированию MongoDB](https://docs.mongodb.com/manual/administration/).
>
>Пользователь (разработчик) написал в канал поддержки, что у него уже 3 минуты происходит CRUD операция в MongoDB и её 
>нужно прервать. 
>
>Вы как инженер поддержки решили произвести данную операцию:
>- напишите список операций, которые вы будете производить для остановки запроса пользователя
>- предложите вариант решения проблемы с долгими (зависающими) запросами в MongoDB

- для остановки запроса пользователя нужно:

  - найти ID операции, на которую жалуется пользователь. Это можно сделать с помощью [команды `$currentOp`](https://docs.mongodb.com/manual/reference/operator/aggregation/currentOp/)
  - выполнить [процедуру `db.killOp()`](https://docs.mongodb.com/manual/reference/method/db.killOp/) передав ей найденный ID операции.

- вариант решения проблемы долгих запросов - добавление к запросам, которые могут выполняться слишком долго, [метода `.maxTimeMS()`](https://docs.mongodb.com/manual/reference/method/cursor.maxTimeMS/). Он позволит при превышении заданного таймаута прервать выполнение запроса в т.н. `interrupt point` - точке в жизненном цикле операции, в которой прерывание будет безопасным.

## Задача 2

>Перед выполнением задания познакомьтесь с документацией по [Redis latency troobleshooting](https://redis.io/topics/latency).
>
>Вы запустили инстанс Redis для использования совместно с сервисом, который использует механизм TTL. 
>Причем отношение количества записанных key-value значений к количеству истёкших значений есть величина постоянная и
>увеличивается пропорционально количеству реплик сервиса. 
>
>При масштабировании сервиса до N реплик вы увидели, что:
>- сначала происходит рост отношения записанных значений к истекшим
>- Redis блокирует операции записи
>
>Как вы думаете, в чем может быть проблема?
 
Исходя из описания ситуации, сперва происходит активное наполнение базы данных некими записями. И можно предположить, что TTL у этих записей был одинаковым. Если срок жизни значительного числа записей истечёт в одну и ту же секунду, то [механизм чистки записей](https://redis.io/topics/latency#latency-generated-by-expires) заблокирует базу. Такое поведение вызвано тем, что если в случайной выборке GC обнаружит более 25% просроченных записей он будет работать в цикле пока процент истёкших записей не уменьшится.  
Полагаю, что подобную проблему на практике, как и сказано в документации, можно увидеть скорее при неаккуратном использовании оператора [EXPIREAT](https://redis.io/commands/expireat), чем по неудачному стечению обстоятельств.

## Задача 3

>Перед выполнением задания познакомьтесь с документацией по [Common Mysql errors](https://dev.mysql.com/doc/refman/8.0/en/common-errors.html).
>
>Вы подняли базу данных MySQL для использования в гис-системе. При росте количества записей, в таблицах базы,
>пользователи начали жаловаться на ошибки вида:
>```python
>InterfaceError: (InterfaceError) 2013: Lost connection to MySQL server during query u'SELECT..... '
>```
>
>Как вы думаете, почему это начало происходить и как локализовать проблему?
>
>Какие пути решения данной проблемы вы можете предложить?

Опишу три причины появления данной ошибки, затем их диагностику и метод устранения.

Данная ошибка может происходить по следующим причинам:

1. потеря сетевой связности между клиентом и сервером

1. сервер посчитал, что соединение существует слишком долго и его нужно прервать. Такое может происходить из-за слишком сложного запроса.

1. клиент пытается инициировать соединение для выполнения запроса, но из-за низкого качества связи, либо низкого быстродействия сервера, соединение сбрасывается по таймауту

Для локализации проблемы нужно:

1. обратиться к сетевой статистике соединений с сервером, посмотреть на количество повреждённых и отброшенных пакетов

1. включить slow_log, посмотреть информацию по проблемному запросу к базе и сопоставить время его исполнения со значением таймаута неактивных клиентских соединений

1. посмотреть на статистику сброшенных подключений запросом `SHOW GLOBAL STATUS LIKE 'Aborted_connects'`

Для решения проблемы нужно:

1. исправить проблему в сети передачи данных

1. либо упростить запрос к базе, либо увеличить таймаут [net_read_timeout](https://dev.mysql.com/doc/refman/8.0/en/server-system-variables.html#sysvar_net_read_timeout).

1. увеличить таймаут при подключении [connect_timeout](https://dev.mysql.com/doc/refman/8.0/en/server-system-variables.html#sysvar_connect_timeout)

## Задача 4

>Перед выполнением задания ознакомтесь со статьей [Common PostgreSQL errors](https://www.percona.com/blog/2020/06/05/10-common-postgresql-errors/) из блога Percona.
>
>Вы решили перевезти гис-систему из задачи 3 на PostgreSQL, так как прочитали в документации, что эта СУБД работает с 
>большим объемом данных лучше, чем MySQL.
>
>После запуска пользователи начали жаловаться, что СУБД время от времени становится недоступной. В dmesg вы видите, что:
>
>`postmaster invoked oom-killer`
>
>Как вы думаете, что происходит?
>
>Как бы вы решили данную проблему?

Проблема вызвана нехваткой свободной оперативной памяти. Когда она заканчивается `oom-killer` завершает процесс PostgreSQL. Пока не будет запущен новый процесс PostgreSQL база не будет доступна пользователям.

В качестве решения данной проблемы необходимо сперва оценить адекватность настройки СУБД, возможно будет достаточно оптимизации.  
Также, возможно, были допущены погрешности в схеме базы данных, что привело к нерациональному потреблению ОЗУ.  
Ну и самый простой вариант решения - провести вертикальное масштабирование, т.е. добавить памяти на хосте с СУБД.
